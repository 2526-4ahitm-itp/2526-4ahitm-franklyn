//! This file is completely AI generated by claude sonnet 4.5
//! as this is just a code we use for dev environments that
//! don't have good screen record capabilities and are not
//! yet supported by xcap

use std::sync::OnceLock;
use std::time::{SystemTime, UNIX_EPOCH};

static RANDOM_COLORS: OnceLock<(u8, u8, u8, u8, u8, u8)> = OnceLock::new();

fn get_random_colors() -> (u8, u8, u8, u8, u8, u8) {
    *RANDOM_COLORS.get_or_init(|| {
        let time_ms = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_nanos() as u32;
        let mut seed = time_ms.wrapping_mul(1103515245).wrapping_add(12345);

        let mut splitmix32 = || {
            seed = seed.wrapping_add(0x9E3779B9);
            let mut z = seed;
            z = z ^ (z >> 15);
            z = z.wrapping_mul(0x85EBCA77);
            z = z ^ (z >> 13);
            z = z.wrapping_mul(0xC2B2AE3D);
            z ^ (z >> 16)
        };

        let base_r = (splitmix32() % 60 + 20) as u8;
        let base_g = (splitmix32() % 60 + 20) as u8;
        let base_b = (splitmix32() % 60 + 20) as u8;
        let alt_r = (splitmix32() % 60 + 20) as u8;
        let alt_g = (splitmix32() % 60 + 20) as u8;
        let alt_b = (splitmix32() % 60 + 20) as u8;

        (base_r, base_g, base_b, alt_r, alt_g, alt_b)
    })
}

/// Generates a smooth, non-flickering random image at 16:9 aspect ratio
/// Returns (width, height, raw_rgba_data)
pub fn generate_random_image(width: usize) -> (usize, usize, Vec<u8>) {
    let height = (width * 9) / 16;
    let mut raw = vec![0u8; width * height * 4];

    // Get time for movement and display
    let time_ms = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_millis() as u64;

    // Get random colors (generated once at program startup)
    let (base_r, base_g, base_b, alt_r, alt_g, alt_b) = get_random_colors();

    // Movement: offset moves down continuously
    let offset = (time_ms / 50) % (height as u64); // Moves 20px per second

    // Simple moving horizontal bars
    let bar_height = height / 8;

    for y in 0..height {
        let moved_y = (y + offset as usize) % height;
        let bar_index = moved_y / bar_height;

        // Alternate between two colors
        let (r, g, b) = if bar_index % 2 == 0 {
            (base_r, base_g, base_b)
        } else {
            (alt_r, alt_g, alt_b)
        };

        // Fill entire row
        for x in 0..width {
            let idx = (y * width + x) * 4;
            raw[idx] = r;
            raw[idx + 1] = g;
            raw[idx + 2] = b;
            raw[idx + 3] = 255;
        }
    }

    // Draw time
    encode_time_pixels(&mut raw, width, time_ms);

    (width, height, raw)
}

/// Encodes time as visible pixels in the top-left corner
fn encode_time_pixels(raw: &mut [u8], width: usize, time_ms: u64) {
    let seconds = (time_ms / 1000) % 60;
    let minutes = (time_ms / 60000) % 60;
    let hours = (time_ms / 3600000) % 24;

    // Calculate scale to reach ~half screen width
    // Base size: 8 digits * 5px + spacing ≈ 64px
    // Target: width / 2
    // Scale: (width / 2) / 64 ≈ width / 128
    let scale = (width / 128).max(1);

    // Simple 5x7 digit patterns (just showing segments for readability)
    let draw_digit = |raw: &mut [u8],
                      width: usize,
                      x_offset: usize,
                      y_offset: usize,
                      digit: u64,
                      scale: usize| {
        // Simple bar pattern representing the digit (0-9)
        let patterns = [
            0b11111101, // 0
            0b01100000, // 1
            0b11011011, // 2
            0b11110011, // 3
            0b01100111, // 4
            0b10110111, // 5
            0b10111111, // 6
            0b11100000, // 7
            0b11111111, // 8
            0b11110111, // 9
        ];

        let pattern = patterns[digit as usize % 10];

        // Draw 7-segment-style digit (simplified) at scale
        for dy in 0..7 {
            for dx in 0..5 {
                let bit_set = match (dx, dy) {
                    (1..=3, 0) => pattern & 0b10000000 != 0, // top
                    (4, 1..=2) => pattern & 0b01000000 != 0, // top-right
                    (4, 4..=5) => pattern & 0b00100000 != 0, // bottom-right
                    (1..=3, 6) => pattern & 0b00010000 != 0, // bottom
                    (0, 4..=5) => pattern & 0b00001000 != 0, // bottom-left
                    (0, 1..=2) => pattern & 0b00000100 != 0, // top-left
                    (1..=3, 3) => pattern & 0b00000010 != 0, // middle
                    _ => false,
                };

                if bit_set {
                    // Draw each pixel as a scale x scale block
                    for dy2 in 0..scale {
                        for dx2 in 0..scale {
                            let px = x_offset + dx * scale + dx2;
                            let py = y_offset + dy * scale + dy2;
                            if px < width && py < (width * 9) / 16 {
                                let idx = (py * width + px) * 4;
                                raw[idx] = 80; // R
                                raw[idx + 1] = 80; // G
                                raw[idx + 2] = 80; // B
                                raw[idx + 3] = 255; // A
                            }
                        }
                    }
                }
            }
        }
    };

    // Helper to draw a colon (two dots) at scale
    let draw_colon = |raw: &mut [u8], width: usize, x: usize, y: usize, scale: usize| {
        let dot_size = scale * 2;
        // Top dot
        for dy in 0..dot_size {
            for dx in 0..dot_size {
                let px = x + dx;
                let py = y + 2 * scale + dy;
                if px < width && py < (width * 9) / 16 {
                    let idx = (py * width + px) * 4;
                    raw[idx] = 80;
                    raw[idx + 1] = 80;
                    raw[idx + 2] = 80;
                    raw[idx + 3] = 255;
                }
            }
        }
        // Bottom dot
        for dy in 0..dot_size {
            for dx in 0..dot_size {
                let px = x + dx;
                let py = y + 5 * scale + dy;
                if px < width && py < (width * 9) / 16 {
                    let idx = (py * width + px) * 4;
                    raw[idx] = 80;
                    raw[idx + 1] = 80;
                    raw[idx + 2] = 80;
                    raw[idx + 3] = 255;
                }
            }
        }
    };

    // Draw HH:MM:SS scaled to reach ~half screen width
    let spacing = 8 * scale;
    let start_x = 10;
    let start_y = 10;

    draw_digit(raw, width, start_x, start_y, hours / 10, scale);
    draw_digit(raw, width, start_x + spacing, start_y, hours % 10, scale);

    // Colon
    draw_colon(raw, width, start_x + spacing * 2 + scale, start_y, scale);

    draw_digit(
        raw,
        width,
        start_x + spacing * 3,
        start_y,
        minutes / 10,
        scale,
    );
    draw_digit(
        raw,
        width,
        start_x + spacing * 4,
        start_y,
        minutes % 10,
        scale,
    );

    // Colon
    draw_colon(raw, width, start_x + spacing * 5 + scale, start_y, scale);

    draw_digit(
        raw,
        width,
        start_x + spacing * 6,
        start_y,
        seconds / 10,
        scale,
    );
    draw_digit(
        raw,
        width,
        start_x + spacing * 7,
        start_y,
        seconds % 10,
        scale,
    );
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generates_correct_dimensions() {
        let (w, h, raw) = generate_random_image(1920);
        assert_eq!(w, 1920);
        assert_eq!(h, 1080);
        assert_eq!(raw.len(), 1920 * 1080 * 4);
    }

    #[test]
    fn test_same_program_run_produces_same_colors() {
        let (_, _, raw1) = generate_random_image(640);
        let (_, _, raw2) = generate_random_image(640);
        assert_eq!(raw1, raw2);
    }
}
