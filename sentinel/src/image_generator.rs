//! This file is completely AI generated by claude sonnet 4.5
//! as this is just a code we use for dev environments that
//! don't have good screen record capabilities and are not
//! yet supported by xcap

use std::sync::{Mutex, OnceLock};
use std::time::{SystemTime, UNIX_EPOCH};

struct BackgroundCache {
    width: usize,
    height: usize,
    bar_height: usize,
    color_a: (u8, u8, u8),
    color_b: (u8, u8, u8),
    data: Vec<u8>,
}

static STARTUP_COLORS: OnceLock<((u8, u8, u8), (u8, u8, u8))> = OnceLock::new();
static BACKGROUND_CACHE: OnceLock<Mutex<BackgroundCache>> = OnceLock::new();

fn fill_row(row: &mut [u8], (r, g, b): (u8, u8, u8)) {
    for px in row.chunks_exact_mut(4) {
        px[0] = r;
        px[1] = g;
        px[2] = b;
        px[3] = 255;
    }
}

fn startup_colors() -> ((u8, u8, u8), (u8, u8, u8)) {
    let time_ms = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_millis() as u64;
    let mut seed = time_ms ^ (time_ms >> 11) ^ (time_ms << 7);
    let mut next_byte = || {
        seed ^= seed << 13;
        seed ^= seed >> 7;
        seed ^= seed << 17;
        ((seed >> 56) & 0xFF) as u8
    };
    let base_r = 25 + (next_byte() % 11);
    let base_g = 25 + (next_byte() % 11);
    let base_b = 25 + (next_byte() % 11);
    let (r1, g1, b1) = (base_r, base_g, base_b);
    let (r2, g2, b2) = (
        (base_r.saturating_add(8)).min(45),
        (base_g.saturating_add(6)).min(45),
        (base_b.saturating_add(8)).min(45),
    );
    ((r1, g1, b1), (r2, g2, b2))
}

/// Generates a smooth, non-flickering random image at 16:9 aspect ratio
/// Returns (width, height, raw_rgba_data)
pub fn generate_random_image(width: usize) -> (usize, usize, Vec<u8>) {
    let height = (width * 9) / 16;
    let mut raw = vec![0u8; width * height * 4];

    // Get time for movement and display
    let time_ms = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_millis() as u64;

    // Movement: offset moves down continuously
    let offset = (time_ms / 50) % (height as u64); // Moves 20px per second

    // Simple moving horizontal bars
    let bar_height = height / 8;

    let (color_a, color_b) = *STARTUP_COLORS.get_or_init(startup_colors);
    let cache = BACKGROUND_CACHE.get_or_init(|| {
        Mutex::new(BackgroundCache {
            width: 0,
            height: 0,
            bar_height: 0,
            color_a: (0, 0, 0),
            color_b: (0, 0, 0),
            data: Vec::new(),
        })
    });

    let row_bytes = width * 4;
    {
        let mut cache = cache.lock().expect("background cache lock");
        if cache.width != width
            || cache.height != height
            || cache.bar_height != bar_height
            || cache.color_a != color_a
            || cache.color_b != color_b
        {
            cache.width = width;
            cache.height = height;
            cache.bar_height = bar_height;
            cache.color_a = color_a;
            cache.color_b = color_b;
            cache.data.resize(width * height * 4, 0);

            let mut row_a = vec![0u8; row_bytes];
            let mut row_b = vec![0u8; row_bytes];
            fill_row(&mut row_a, color_a);
            fill_row(&mut row_b, color_b);

            for y in 0..height {
                let bar_index = y / bar_height;
                let row = if bar_index % 2 == 0 { &row_a } else { &row_b };
                let start = y * row_bytes;
                cache.data[start..start + row_bytes].copy_from_slice(row);
            }
        }

        for y in 0..height {
            let src_y = (y + offset as usize) % height;
            let src = &cache.data[src_y * row_bytes..(src_y + 1) * row_bytes];
            let dst = &mut raw[y * row_bytes..(y + 1) * row_bytes];
            dst.copy_from_slice(src);
        }
    }

    // Draw time
    encode_time_pixels(&mut raw, width, height, time_ms);

    (width, height, raw)
}

/// Encodes time as visible pixels in the top-left corner
fn encode_time_pixels(raw: &mut [u8], width: usize, height: usize, time_ms: u64) {
    let seconds = (time_ms / 1000) % 60;
    let minutes = (time_ms / 60000) % 60;
    let hours = (time_ms / 3600000) % 24;

    // Calculate scale to reach ~half screen width
    // Base size: 8 digits * 5px + spacing ≈ 64px
    // Target: width / 2
    // Scale: (width / 2) / 64 ≈ width / 128
    let scale = (width / 128).max(1);

    // Simple 5x7 digit patterns (just showing segments for readability)
    let draw_digit = |raw: &mut [u8],
                      width: usize,
                      x_offset: usize,
                      y_offset: usize,
                      digit: u64,
                      scale: usize| {
        // Simple bar pattern representing the digit (0-9)
        let patterns = [
            0b11111101, // 0
            0b01100000, // 1
            0b11011011, // 2
            0b11110011, // 3
            0b01100111, // 4
            0b10110111, // 5
            0b10111111, // 6
            0b11100000, // 7
            0b11111111, // 8
            0b11110111, // 9
        ];

        let pattern = patterns[digit as usize % 10];

        // Draw 7-segment-style digit (simplified) at scale
        for dy in 0..7 {
            for dx in 0..5 {
                let bit_set = match (dx, dy) {
                    (1..=3, 0) => pattern & 0b10000000 != 0, // top
                    (4, 1..=2) => pattern & 0b01000000 != 0, // top-right
                    (4, 4..=5) => pattern & 0b00100000 != 0, // bottom-right
                    (1..=3, 6) => pattern & 0b00010000 != 0, // bottom
                    (0, 4..=5) => pattern & 0b00001000 != 0, // bottom-left
                    (0, 1..=2) => pattern & 0b00000100 != 0, // top-left
                    (1..=3, 3) => pattern & 0b00000010 != 0, // middle
                    _ => false,
                };

                if bit_set {
                    // Draw each pixel as a scale x scale block
                    for dy2 in 0..scale {
                        for dx2 in 0..scale {
                            let px = x_offset + dx * scale + dx2;
                            let py = y_offset + dy * scale + dy2;
                            if px < width && py < height {
                                let idx = (py * width + px) * 4;
                                raw[idx] = 80; // R
                                raw[idx + 1] = 80; // G
                                raw[idx + 2] = 80; // B
                                raw[idx + 3] = 255; // A
                            }
                        }
                    }
                }
            }
        }
    };

    // Helper to draw a colon (two dots) at scale
    let draw_colon = |raw: &mut [u8], width: usize, x: usize, y: usize, scale: usize| {
        let dot_size = scale * 2;
        // Top dot
        for dy in 0..dot_size {
            for dx in 0..dot_size {
                let px = x + dx;
                let py = y + 2 * scale + dy;
                if px < width && py < height {
                    let idx = (py * width + px) * 4;
                    raw[idx] = 80;
                    raw[idx + 1] = 80;
                    raw[idx + 2] = 80;
                    raw[idx + 3] = 255;
                }
            }
        }
        // Bottom dot
        for dy in 0..dot_size {
            for dx in 0..dot_size {
                let px = x + dx;
                let py = y + 5 * scale + dy;
                if px < width && py < height {
                    let idx = (py * width + px) * 4;
                    raw[idx] = 80;
                    raw[idx + 1] = 80;
                    raw[idx + 2] = 80;
                    raw[idx + 3] = 255;
                }
            }
        }
    };

    // Draw HH:MM:SS scaled to reach ~half screen width
    let spacing = 8 * scale;
    let start_x = 10;
    let start_y = 10;

    draw_digit(raw, width, start_x, start_y, hours / 10, scale);
    draw_digit(raw, width, start_x + spacing, start_y, hours % 10, scale);

    // Colon
    draw_colon(raw, width, start_x + spacing * 2 + scale, start_y, scale);

    draw_digit(
        raw,
        width,
        start_x + spacing * 3,
        start_y,
        minutes / 10,
        scale,
    );
    draw_digit(
        raw,
        width,
        start_x + spacing * 4,
        start_y,
        minutes % 10,
        scale,
    );

    // Colon
    draw_colon(raw, width, start_x + spacing * 5 + scale, start_y, scale);

    draw_digit(
        raw,
        width,
        start_x + spacing * 6,
        start_y,
        seconds / 10,
        scale,
    );
    draw_digit(
        raw,
        width,
        start_x + spacing * 7,
        start_y,
        seconds % 10,
        scale,
    );
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generates_correct_dimensions() {
        let (w, h, raw) = generate_random_image(1920);
        assert_eq!(w, 1920);
        assert_eq!(h, 1080);
        assert_eq!(raw.len(), 1920 * 1080 * 4);
    }

    #[test]
    fn test_different_calls_produce_different_images() {
        let (_, _, raw1) = generate_random_image(640);
        std::thread::sleep(std::time::Duration::from_millis(210)); // > 200ms
        let (_, _, raw2) = generate_random_image(640);
        assert_ne!(raw1, raw2);
    }
}
